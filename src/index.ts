import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { getFallbackMetricsFromFontFile, pickFontFileForFallbackGeneration } from './utils';
import { CssVariable, FontFaceProperty, FontOutput, LocalFontOptions } from './types';

// Reset
const RESET = '\x1b[0m';

// Text attributes
const BOLD = '\x1b[1m';

// Foreground colors
const RED = '\x1b[31m';
const YELLOW = '\x1b[33m';
const BLUE = '\x1b[34m';

// Bright foreground colors
const BRIGHT_RED = '\x1b[31;1m';
const BRIGHT_BLUE = '\x1b[34;1m';
const BRIGHT_WHITE = '\x1b[37;1m';

const MOVE_CURSOR_FORWARD = (columns: number) => `\x1b[${columns}C`;

function showLoader(message: string) {
  const loaderFrames = [
    '{/////}',
    `{${BRIGHT_BLUE}~${BLUE}////}${RESET}`,
    `{/${BRIGHT_BLUE}~${BLUE}///}${RESET}`,
    `{//${BRIGHT_BLUE}~${BLUE}//}${RESET}`,
    `{///${BRIGHT_BLUE}~${BLUE}/}${RESET}`,
    `{////${BRIGHT_BLUE}~${BLUE}}${RESET}`,
  ];
  let frameIndex = 0;
  let isFirstRun = true;

  const interval = setInterval(() => {
    if (isFirstRun) {
      // Add a newline for spacing on the first run
      process.stdout.write('\n');
      isFirstRun = false;
    }
    // Move to the start of the line and clear it
    process.stdout.write('\r\x1B[K');
    // Print the loader
    process.stdout.write(`${BOLD}${BLUE}${loaderFrames[frameIndex]}${RESET} ${message}`);
    frameIndex = (frameIndex + 1) % loaderFrames.length;
  }, 200);

  return (message: string) => {
    clearInterval(interval);
    process.stdout.write('\r\x1B[K');
    console.log(message);
  };
}

let fontFromBuffer: (arg0: Buffer) => any;
try {
  const mod = require('./fontkit').default;
  fontFromBuffer = mod.default || mod;
} catch {
  /* ignore */
}

function generateHash(content: Buffer) {
  return crypto.createHash('sha256').update(content).digest('hex').slice(0, 16);
}

function generateCssFilenameHash(fontPaths: string[]) {
  const combinedPaths = fontPaths.join('|');
  return generateHash(Buffer.from(combinedPaths));
}

function appendCssToFile(filePath: string, cssContent: string) {
  const comment = '/* Automatically generated by package @eloraa/font-loader */';
  try {
    const existingContent = fs.readFileSync(filePath, 'utf-8');
    const newContent = `${comment}\n${cssContent}\n${existingContent}`;
    fs.writeFileSync(filePath, newContent);
  } catch (error: unknown) {
    if (error instanceof Error) {
      const errnoException = error as NodeJS.ErrnoException;
      if (errnoException.code === 'ENOENT') {
        fs.writeFileSync(filePath, `${comment}\n${cssContent}\n`);
      } else {
        console.error(`${path.relative(process.cwd(), filePath)}: ${errnoException.message}`);
      }
    }
  }
}

function detectFontFormat(buffer: ArrayBuffer) {
  const uint8Array = new Uint8Array(buffer);

  if (uint8Array[0] === 0x77 && uint8Array[1] === 0x4f && uint8Array[2] === 0x46 && uint8Array[3] === 0x32) {
    return 'woff2';
  }

  if (uint8Array[0] === 0x77 && uint8Array[1] === 0x4f && uint8Array[2] === 0x46 && uint8Array[3] === 0x46) {
    return 'woff';
  }

  if (uint8Array[0] === 0x4f && uint8Array[1] === 0x54 && uint8Array[2] === 0x54 && uint8Array[3] === 0x4f) {
    return 'opentype';
  }

  if (uint8Array[0] === 0x00 && uint8Array[1] === 0x01 && uint8Array[2] === 0x00 && uint8Array[3] === 0x00) {
    return 'truetype';
  }

  if (uint8Array.length >= 6 && uint8Array[0] === 0x00 && uint8Array[1] === 0x01 && uint8Array[2] === 0x00 && uint8Array[3] === 0x00 && uint8Array[4] === 0x00 && uint8Array[5] === 0x01) {
    return 'type1';
  }

  return 'unknown';
}

const resolvePath = (caller: string, _path: string) =>
  path.isAbsolute(_path)
    ? path.join(process.cwd(), './' + _path)
    : path.resolve(process.cwd(), path.resolve(caller) === process.cwd() ? './' + _path : path.isAbsolute(caller) ? './' + caller : caller, _path);

function localFont<T extends CssVariable | undefined = undefined>(options: LocalFontOptions<T>): FontOutput<T> | undefined {
  const { src, outputDir = './fonts', display = 'swap', weight, style, adjustFontFallback = 'Arial', variable, declarations = [], outputCss, appendTo, fontDir = 'localfont' } = options;

  if (!src || src?.length === 0) {
    return;
  }

  // Check if fontDir exists
  if (!fs.existsSync(resolvePath('/', fontDir))) {
    console.log(
      `\n\n${MOVE_CURSOR_FORWARD(5)}${BOLD}${BLUE}@eloraa/font-loader${RESET} ${BLUE}v1.0.0${RESET}\n${MOVE_CURSOR_FORWARD(
        5
      )}Font directory not found: ${BOLD}${BRIGHT_RED}${fontDir}${RESET}\n${MOVE_CURSOR_FORWARD(5)}Please create the directory and place your font files there.\n${MOVE_CURSOR_FORWARD(
        5
      )}or use the ${YELLOW}fontDir${RESET} option to specify a different directory.\n`
    );
    return;
  }

  const fontFiles = Array.isArray(src) ? src : [{ path: src, weight, style }];
  const fontCss: string[] = [];
  const fontMetadata: any[] = [];

  const fontPaths = fontFiles.map(f => resolvePath(fontDir, f.path));

  const fontHash = generateCssFilenameHash(fontPaths);
  const fallbackFontName = `__font_Fallback_${fontHash}`;

  let variableName: string | undefined;
  let className: string | undefined;

  const cssFileName = outputCss ? `${outputCss}` : `${fontHash}.css`;
  const cssFilePath = path.join(resolvePath(fontDir, outputDir), cssFileName);
  if (fs.existsSync(cssFilePath)) {
    const cssContent = fs.readFileSync(cssFilePath, 'utf-8');

    const classNameMatch = cssContent.match(/\.(__className_[a-zA-Z0-9]+)\s*\{/);
    className = classNameMatch ? classNameMatch[1] : undefined;

    const fontFamilyMatch = cssContent.match(/font-family:\s*'([^']+)',\s*'([^']+)';/);
    const fontFamily = fontFamilyMatch ? fontFamilyMatch[1] : undefined;

    const variableNameMatch = cssContent.match(/--([a-zA-Z0-9_-]+)\s*:\s*'([^']+)',\s*'([^']+)';/);
    variableName = variableNameMatch ? variableNameMatch[2] : undefined;

    const output: FontOutput<T> = {
      className,
      style: {
        fontFamily: `${variableName || fontFamily}, ${fallbackFontName}`,
      },
    };

    if (weight) {
      output.style.fontWeight = parseInt(weight, 10);
    }

    if (style) {
      output.style.fontStyle = style;
    }

    if (variable) {
      output.variable = variable;

      if (!variableNameMatch) {
        const variableCss = `.${className} {\n  ${variable}: '${variableName}', '${fallbackFontName}';\n}\n`;
        fs.appendFileSync(cssFilePath, variableCss);
      }
    } else {
      const variableBlockRegex = new RegExp(`\\.__variable_${fontHash}[^}]*}\\s*`, 'g');
      if (variableNameMatch) {
        const updatedCssContent = cssContent.replace(variableBlockRegex, '');
        fs.writeFileSync(cssFilePath, updatedCssContent, 'utf-8');
      }
    }

    return output;
  }

  console.log(`\n${MOVE_CURSOR_FORWARD(5)}${BOLD}${BLUE}@eloraa/font-loader${RESET} ${BLUE}v1.0.0${RESET}\n`);

  const stopLoader = showLoader('Starting font processing...');

  for (const fontFile of fontFiles) {
    const { path: fontPath, weight: fileWeight, style: fileStyle } = fontFile;
    try {
      const resolvedPath = resolvePath(fontDir, fontPath);
      console.log(`Processing font file: ${BRIGHT_WHITE}${path.relative(process.cwd(), resolvedPath)}${RESET}`);
      const fileContent = fs.readFileSync(resolvedPath);
      const font = fontFromBuffer?.(fileContent);
      fontMetadata.push(font);

      const fileHash = generateHash(fileContent);
      const ext = path.extname(resolvedPath);
      const gibberishFontFileName = `${fileHash}${ext}`;
      const outputPath = path.join(resolvePath(fontDir, outputDir), gibberishFontFileName);
      fs.mkdirSync(path.dirname(outputPath), { recursive: true });
      fs.writeFileSync(outputPath, fileContent);
      console.log(`Saved ${BOLD}${BLUE}${font.familyName}${RESET} font file to ${path.relative(process.cwd(), outputPath)}`);

      variableName = `__font_${fontHash}`;
      className = `__className_${fontHash}`;

      const format = detectFontFormat(fileContent);

      const fontFaceProperties: FontFaceProperty[] = [
        ['font-family', `'${variableName}'`],
        ['src', `url(./${gibberishFontFileName})${format !== 'unknown' ? ` format(\'${format}\')` : ''}`],
        ['font-display', display],
      ];

      if (fileWeight) {
        fontFaceProperties.push(['font-weight', fileWeight]);
      }

      if (fileStyle) {
        fontFaceProperties.push(['font-style', fileStyle]);
      }

      for (const declaration of declarations) {
        if (Array.isArray(declaration) && declaration.length === 2) {
          fontFaceProperties.push(declaration as unknown as FontFaceProperty);
        } else if (typeof declaration === 'object' && 'prop' in declaration && 'value' in declaration) {
          fontFaceProperties.push([declaration.prop, declaration.value]);
        }
      }

      const css = `@font-face {\n${fontFaceProperties.map(([property, value]) => `  ${property}: ${value};`).join('\n')}\n}\n`;
      fontCss.push(css);
    } catch (error: unknown) {
      console.error(`${error instanceof Error ? error.message : error}`);
      continue;
    }
  }

  if (adjustFontFallback !== false) {
    const fallbackFontFile = pickFontFileForFallbackGeneration(fontMetadata);
    const fallbackMetrics = getFallbackMetricsFromFontFile(fallbackFontFile, adjustFontFallback === 'Times New Roman' ? 'serif' : 'sans-serif');

    const fallbackCss = `@font-face {\n  font-family: '${fallbackFontName}';\n  src: local('${fallbackMetrics.fallbackFont}');\n  ascent-override: ${fallbackMetrics.ascentOverride};\n  descent-override: ${fallbackMetrics.descentOverride};\n  line-gap-override: ${fallbackMetrics.lineGapOverride};\n  size-adjust: ${fallbackMetrics.sizeAdjust};\n}\n`;

    fontCss.push(fallbackCss);

    const classCss = `.${className} {\n  font-family: '${variableName}', '${fallbackFontName}';\n}\n`;
    fontCss.push(classCss);

    if (variable) {
      const variableCss = `.__variable_${fontHash} {\n  ${variable}: '${variableName}', '${fallbackFontName}';\n}\n`;
      fontCss.push(variableCss);
    }
  }

  if (!className || !variableName) {
    // stopLoader(`\n${YELLOW}Warning${RESET}: Make sure you've copied your font files to ${BOLD}${fontDir}${RESET} directory.\n`);

    stopLoader(`
      ${RED}Error${RESET}: Make sure you've copied your font files to ${BOLD}${fontDir}${RESET} directory.
    `);
    return;
  }

  try {
    if (appendTo) {
      appendCssToFile(resolvePath(fontDir, appendTo), fontCss.join('\n'));
    } else {
      if (!fs.existsSync(cssFilePath)) {
        fs.mkdirSync(path.dirname(cssFilePath), { recursive: true });
      }
      fs.writeFileSync(cssFilePath, fontCss.join('\n'));
    }
  } catch (error: unknown) {
    console.error(`${error instanceof Error ? error.message : error}`);
  }

  const output: FontOutput<T> = {
    className: className,
    style: {
      fontFamily: `${variableName}, ${fallbackFontName}`,
    },
  };

  if (weight) {
    output.style.fontWeight = parseInt(weight, 10);
  }

  if (style) {
    output.style.fontStyle = style;
  }

  if (variable) {
    output.variable = variable;
  }

  stopLoader(`
     ✨${BRIGHT_WHITE}Font processing complete.${RESET}
     Your CSS file can be found at ${BOLD}${BLUE}${path.relative(process.cwd(), cssFilePath)}${RESET}.
     Make sure to import the generated CSS file in your project.
`);

  return output;
}

export { localFont };
